#!/usr/bin/env -S uv run --script
#
# /// script
# dependencies = [
#   "typer",
#   "rich",
#   "pytest",
# ]
# [tool.uv]
# exclude-newer = "2025-01-16T00:00:00Z"
# ///

# =============================================================================
# AI-NAVIGATION: Testing
# =============================================================================
# Run tests:
#   cp bin/agent-fleet /tmp/agent_fleet_test.py
#   uvx --with pytest --with typer --with rich pytest /tmp/agent_fleet_test.py -v
#   rm /tmp/agent_fleet_test.py
#
# Tests are located at:
#   Line 336: # AI-SEARCH: TESTS (17 test functions)
# =============================================================================

"""
Agent Fleet - Manage parallel JJ workspaces for AI coding agents

Usage:
    agent-fleet create "task description"    # Create workspace and launch claude
    agent-fleet list                         # Show active workspaces
    agent-fleet cleanup <workspace-name>     # Remove specific workspace
    agent-fleet cleanup --all                # Remove all agent workspaces
"""

import json
import os
import subprocess
import sys
from datetime import datetime
from pathlib import Path
from typing import Optional

import typer
from rich.console import Console
from rich.table import Table

app = typer.Typer(help="Manage parallel JJ workspaces for AI coding agents")
console = Console()

# Configuration
WORKTREES_DIR = ".worktrees"
STATE_FILE = ".worktrees/.agent-fleet.json"
WORKSPACE_PREFIX = "agent-"


# =============================================================================
# State Management
# =============================================================================


def get_repo_root() -> Path:
    """Get the repository root directory."""
    try:
        result = subprocess.run(
            ["jj", "workspace", "root"],
            capture_output=True,
            text=True,
            check=True,
        )
        return Path(result.stdout.strip())
    except subprocess.CalledProcessError as e:
        console.print(f"[red]Error: Not in a jj repository[/red]", file=sys.stderr)
        console.print(f"[dim]{e.stderr}[/dim]", file=sys.stderr)
        raise typer.Exit(1)


def ensure_worktrees_dir(repo_root: Path) -> Path:
    """Ensure .worktrees directory exists."""
    worktrees = repo_root / WORKTREES_DIR
    worktrees.mkdir(exist_ok=True)
    return worktrees


def load_state(repo_root: Path) -> dict:
    """Load state from JSON file."""
    state_path = repo_root / STATE_FILE
    if state_path.exists():
        try:
            return json.loads(state_path.read_text())
        except json.JSONDecodeError:
            console.print(
                "[yellow]Warning: Invalid state file, starting fresh[/yellow]"
            )
    return {"workspaces": {}}


def save_state(repo_root: Path, state: dict):
    """Save state to JSON file."""
    state_path = repo_root / STATE_FILE
    state_path.write_text(json.dumps(state, indent=2))


def generate_task_id() -> str:
    """Generate a unique task ID."""
    return datetime.now().strftime("%Y%m%d-%H%M%S")


def create_task_note(
    task_id: str, description: str, workspace_path: Path, agent: str, repo_root: Path
) -> bool:
    """
    Create a TaskNote in Obsidian vault for tracking agent work.

    Returns True if note was created successfully, False otherwise.
    """
    vault_path = Path.home() / "sync" / "claude-vault" / "00_Inbox" / "Agents"

    # Check if vault exists
    if not vault_path.exists():
        console.print(
            f"[yellow]Warning: Obsidian vault not found at {vault_path}[/yellow]"
        )
        console.print("[dim]Skipping TaskNote creation[/dim]")
        return False

    # Create agents directory if it doesn't exist
    vault_path.mkdir(parents=True, exist_ok=True)

    # Create note file
    note_path = vault_path / f"agent-{task_id}.md"
    created_time = datetime.now().isoformat()
    relative_workspace = workspace_path.relative_to(repo_root)

    note_content = f"""---
task_id: {task_id}
created: {created_time}
agent: {agent}
status: running
workspace: {relative_workspace}
---

# {description}

## Workspace
`{relative_workspace}`

## Notes
(Agent work tracked here)
"""

    try:
        note_path.write_text(note_content)
        console.print(f"[green]✓[/green] TaskNote created: {note_path.name}")
        return True
    except Exception as e:
        console.print(f"[yellow]Warning: Could not create TaskNote:[/yellow] {e}")
        return False


# =============================================================================
# JJ Workspace Operations
# =============================================================================


def create_workspace(name: str, path: Path) -> bool:
    """Create a new jj workspace."""
    try:
        subprocess.run(
            ["jj", "workspace", "add", "--name", name, str(path)],
            check=True,
            capture_output=True,
        )
        return True
    except subprocess.CalledProcessError as e:
        console.print(f"[red]Error creating workspace:[/red]", file=sys.stderr)
        console.print(f"[dim]{e.stderr.decode()}[/dim]", file=sys.stderr)
        return False


def forget_workspace(name: str) -> bool:
    """Forget a jj workspace."""
    try:
        subprocess.run(
            ["jj", "workspace", "forget", name],
            check=True,
            capture_output=True,
        )
        return True
    except subprocess.CalledProcessError as e:
        console.print(f"[yellow]Warning: Could not forget workspace:[/yellow]")
        console.print(f"[dim]{e.stderr.decode()}[/dim]")
        return False


def list_jj_workspaces() -> set[str]:
    """Get list of all jj workspaces."""
    try:
        result = subprocess.run(
            ["jj", "workspace", "list"],
            capture_output=True,
            text=True,
            check=True,
        )
        # Parse output to get workspace names
        workspaces = set()
        for line in result.stdout.strip().split("\n"):
            # Format: "workspace_name: /path/to/workspace"
            if ":" in line:
                name = line.split(":")[0].strip().lstrip("*").strip()
                if name.startswith(WORKSPACE_PREFIX):
                    workspaces.add(name)
        return workspaces
    except subprocess.CalledProcessError:
        return set()


# =============================================================================
# Commands
# =============================================================================


@app.command()
def create(
    description: str = typer.Argument(..., help="Task description for the agent"),
    agent: str = typer.Option(
        "claude-code", "--agent", "-a", help="Agent command to run"
    ),
    auto_accept: bool = typer.Option(
        True, "--auto-accept/--no-auto-accept", help="Auto-accept agent edits"
    ),
):
    """
    Create a new workspace and launch an agent.

    Creates a JJ workspace in .worktrees/, saves the task metadata,
    creates a TaskNote in your Obsidian vault, and launches the
    specified agent with the task description.
    """
    repo_root = get_repo_root()
    worktrees_dir = ensure_worktrees_dir(repo_root)
    state = load_state(repo_root)

    # Generate task ID and paths
    task_id = generate_task_id()
    workspace_name = f"{WORKSPACE_PREFIX}{task_id}"
    workspace_path = worktrees_dir / workspace_name

    console.print(f"[cyan]Creating workspace:[/cyan] {workspace_name}")

    # Create workspace
    if not create_workspace(workspace_name, workspace_path):
        raise typer.Exit(1)

    # Save to state
    state["workspaces"][workspace_name] = {
        "id": task_id,
        "description": description,
        "created": datetime.now().isoformat(),
        "path": str(workspace_path.relative_to(repo_root)),
        "agent": agent,
    }
    save_state(repo_root, state)

    console.print(f"[green]✓[/green] Workspace created at: {workspace_path}")

    # Create TaskNote in Obsidian vault
    create_task_note(task_id, description, workspace_path, agent, repo_root)

    console.print(f"[cyan]Launching {agent}...[/cyan]\n")

    # Change to workspace directory
    os.chdir(workspace_path)

    # Build agent command
    agent_cmd = [agent]
    if auto_accept and agent == "claude-code":
        agent_cmd.append("--accept-edits")

    # Launch agent with the prompt
    # The script will exec and be replaced by the agent process
    os.execvp(agent_cmd[0], agent_cmd + [description])


@app.command()
def list():
    """
    List all active agent workspaces.

    Shows workspace name, description, creation time, and path.
    """
    repo_root = get_repo_root()
    state = load_state(repo_root)

    if not state["workspaces"]:
        console.print("[yellow]No active workspaces[/yellow]")
        return

    # Get actual jj workspaces to check if they still exist
    jj_workspaces = list_jj_workspaces()

    table = Table(title="Agent Fleet Workspaces")
    table.add_column("Workspace", style="cyan")
    table.add_column("Description", style="white")
    table.add_column("Created", style="dim")
    table.add_column("Status", style="green")

    for name, info in sorted(state["workspaces"].items()):
        # Check if workspace still exists in jj
        exists = name in jj_workspaces
        status = "✓ Active" if exists else "⚠ Missing"
        status_style = "green" if exists else "yellow"

        created = datetime.fromisoformat(info["created"])
        created_str = created.strftime("%Y-%m-%d %H:%M")

        table.add_row(
            name,
            info["description"][:50] + ("..." if len(info["description"]) > 50 else ""),
            created_str,
            f"[{status_style}]{status}[/{status_style}]",
        )

    console.print(table)


@app.command()
def cleanup(
    workspace_name: Optional[str] = typer.Argument(
        None, help="Workspace name to clean up (e.g., agent-20250116-123456)"
    ),
    all: bool = typer.Option(False, "--all", help="Clean up all agent workspaces"),
    force: bool = typer.Option(False, "--force", "-f", help="Skip confirmation"),
):
    """
    Clean up agent workspaces.

    Removes workspace from jj and deletes the directory.
    Use --all to clean up all workspaces, or specify a workspace name.
    """
    repo_root = get_repo_root()
    state = load_state(repo_root)

    if not workspace_name and not all:
        console.print(
            "[red]Error: Specify a workspace name or use --all[/red]", file=sys.stderr
        )
        raise typer.Exit(1)

    # Determine which workspaces to clean
    if all:
        workspaces_to_clean = list(state["workspaces"].keys())
        if not workspaces_to_clean:
            console.print("[yellow]No workspaces to clean[/yellow]")
            return

        if not force:
            console.print(
                f"[yellow]About to clean up {len(workspaces_to_clean)} workspaces:[/yellow]"
            )
            for name in workspaces_to_clean:
                console.print(f"  - {name}")
            if not typer.confirm("Continue?"):
                raise typer.Abort()
    else:
        if workspace_name not in state["workspaces"]:
            console.print(
                f"[yellow]Warning: Workspace '{workspace_name}' not in state file[/yellow]"
            )
            console.print("[dim]Attempting cleanup anyway...[/dim]")
        workspaces_to_clean = [workspace_name]

    # Clean up each workspace
    for name in workspaces_to_clean:
        console.print(f"[cyan]Cleaning up:[/cyan] {name}")

        # Forget workspace in jj
        forget_workspace(name)

        # Remove directory
        if name in state["workspaces"]:
            workspace_path = repo_root / state["workspaces"][name]["path"]
        else:
            workspace_path = repo_root / WORKTREES_DIR / name

        if workspace_path.exists():
            try:
                import shutil

                shutil.rmtree(workspace_path)
                console.print(f"[green]✓[/green] Removed directory: {workspace_path}")
            except Exception as e:
                console.print(f"[red]Error removing directory:[/red] {e}")
        else:
            console.print(f"[dim]Directory already removed[/dim]")

        # Remove from state
        if name in state["workspaces"]:
            del state["workspaces"][name]

    # Save updated state
    save_state(repo_root, state)
    console.print(f"[green]✓[/green] Cleaned up {len(workspaces_to_clean)} workspace(s)")


@app.command(epilog="Made with :heart: by the agent-fleet crew")
def diff(
    workspace_name: str = typer.Argument(
        ..., help="Workspace name to show diff for (e.g., agent-20250116-123456)"
    ),
):
    """
    Show diff of changes in a workspace.

    Displays the changes made in the specified workspace compared to the
    parent commit. This is useful for reviewing agent work before merging
    or cleaning up.

    Future implementation will:
    - Run `jj diff -r <workspace>@` to get changes
    - Display with syntax highlighting
    - Support different diff formats (unified, side-by-side)
    - Allow filtering by file path
    """
    console.print(
        "[yellow]⚠ Coming soon![/yellow] The diff command is not yet implemented."
    )
    console.print("\n[dim]Planned features:[/dim]")
    console.print("  • View changes made by the agent")
    console.print("  • Syntax-highlighted diff output")
    console.print("  • Filter by file path")
    console.print("  • Multiple diff formats\n")
    raise typer.Exit(1)


@app.command(epilog="Made with :heart: by the agent-fleet crew")
def note(
    workspace_name: str = typer.Argument(
        ..., help="Workspace name to manage note for (e.g., agent-20250116-123456)"
    ),
    action: str = typer.Option(
        "view",
        "--action",
        "-a",
        help="Action to perform: view, update",
    ),
):
    """
    View or update TaskNotes in Obsidian vault.

    TaskNotes are automatically created when you run 'agent-fleet create'.
    This command lets you view or update existing notes.

    Note location: ~/sync/claude-vault/00_Inbox/Agents/

    Future implementation will:
    - Open note in default editor (view)
    - Update note status (mark complete, add notes)
    - Show note preview in terminal

    Actions:
    - view: Open note in default editor
    - update: Update note status or add notes
    """
    console.print(
        "[yellow]⚠ Coming soon![/yellow] The note command is not yet implemented."
    )
    console.print("\n[dim]Planned features:[/dim]")
    console.print("  • Open TaskNote in editor")
    console.print("  • Update task status")
    console.print("  • Add notes and observations")
    console.print("  • Preview note in terminal\n")
    console.print("[dim]Note: TaskNotes are auto-created with 'agent-fleet create'[/dim]\n")
    raise typer.Exit(1)


# =============================================================================
# AI-SEARCH: TESTS
# Tests (discovered by pytest, ignored during normal execution)
# =============================================================================


def test_generate_task_id_format():
    """Task ID should follow YYYYMMDD-HHMMSS format"""
    task_id = generate_task_id()
    assert len(task_id) == 15  # YYYYMMDD-HHMMSS
    assert task_id[8] == "-"  # Hyphen separator

    # Should be parseable as datetime
    parts = task_id.split("-")
    assert len(parts) == 2
    assert parts[0].isdigit() and len(parts[0]) == 8  # Date part
    assert parts[1].isdigit() and len(parts[1]) == 6  # Time part


def test_generate_task_id_unique():
    """Sequential task IDs should be different (or at least potentially so)"""
    import time

    id1 = generate_task_id()
    time.sleep(0.001)  # Small delay to ensure different timestamp
    id2 = generate_task_id()

    # Note: These might be the same if called in the same second
    # This test just documents the format, not uniqueness guarantee
    assert isinstance(id1, str)
    assert isinstance(id2, str)


def test_load_state_missing_file(tmp_path):
    """Should return empty state when file doesn't exist"""
    repo_root = tmp_path / "test-repo"
    repo_root.mkdir()

    state = load_state(repo_root)
    assert state == {"workspaces": {}}


def test_load_state_invalid_json(tmp_path):
    """Should return empty state when JSON is invalid"""
    repo_root = tmp_path / "test-repo"
    repo_root.mkdir()
    worktrees = repo_root / WORKTREES_DIR
    worktrees.mkdir()

    state_file = repo_root / STATE_FILE
    state_file.write_text("not valid json{{{")

    state = load_state(repo_root)
    assert state == {"workspaces": {}}


def test_save_and_load_state_roundtrip(tmp_path):
    """Should preserve state through save/load cycle"""
    repo_root = tmp_path / "test-repo"
    repo_root.mkdir()
    worktrees = repo_root / WORKTREES_DIR
    worktrees.mkdir()

    # Create test state
    test_state = {
        "workspaces": {
            "agent-20250116-120000": {
                "id": "20250116-120000",
                "description": "Test task",
                "created": "2025-01-16T12:00:00",
                "path": ".worktrees/agent-20250116-120000",
                "agent": "claude-code",
            }
        }
    }

    # Save and load
    save_state(repo_root, test_state)
    loaded_state = load_state(repo_root)

    assert loaded_state == test_state
    assert "agent-20250116-120000" in loaded_state["workspaces"]
    assert loaded_state["workspaces"]["agent-20250116-120000"]["description"] == "Test task"


def test_save_state_creates_directory(tmp_path):
    """Should create .worktrees directory if it doesn't exist"""
    repo_root = tmp_path / "test-repo"
    repo_root.mkdir()

    state = {"workspaces": {}}

    # Directory doesn't exist yet
    assert not (repo_root / WORKTREES_DIR).exists()

    # Create directory first (as the actual code does)
    worktrees = repo_root / WORKTREES_DIR
    worktrees.mkdir(exist_ok=True)

    save_state(repo_root, state)

    # State file should exist now
    assert (repo_root / STATE_FILE).exists()


def test_list_jj_workspaces_parsing():
    """Should parse jj workspace list output correctly"""
    # This is a spec test documenting the expected parsing behavior
    # In real use, this would mock subprocess.run

    sample_output = """default: /path/to/repo
agent-20250116-120000: /path/to/repo/.worktrees/agent-20250116-120000
agent-20250116-123000: /path/to/repo/.worktrees/agent-20250116-123000
* agent-20250116-130000: /path/to/repo/.worktrees/agent-20250116-130000
other-workspace: /path/to/other"""

    # Test the parsing logic directly
    workspaces = set()
    for line in sample_output.strip().split("\n"):
        if ":" in line:
            name = line.split(":")[0].strip().lstrip("*").strip()
            if name.startswith(WORKSPACE_PREFIX):
                workspaces.add(name)

    assert "agent-20250116-120000" in workspaces
    assert "agent-20250116-123000" in workspaces
    assert "agent-20250116-130000" in workspaces
    assert "default" not in workspaces
    assert "other-workspace" not in workspaces
    assert len(workspaces) == 3


def test_list_jj_workspaces_filters_current():
    """Should handle current workspace marker (*)"""
    sample_output = "* agent-20250116-120000: /path/to/workspace"

    workspaces = set()
    for line in sample_output.strip().split("\n"):
        if ":" in line:
            name = line.split(":")[0].strip().lstrip("*").strip()
            if name.startswith(WORKSPACE_PREFIX):
                workspaces.add(name)

    assert "agent-20250116-120000" in workspaces


def test_workspace_prefix_constant():
    """Workspace prefix should be 'agent-'"""
    assert WORKSPACE_PREFIX == "agent-"


def test_workspace_name_format():
    """Workspace names should follow agent-<taskid> format"""
    task_id = "20250116-120000"
    workspace_name = f"{WORKSPACE_PREFIX}{task_id}"

    assert workspace_name == "agent-20250116-120000"
    assert workspace_name.startswith(WORKSPACE_PREFIX)


def test_state_file_location():
    """State file should be in .worktrees/.agent-fleet.json"""
    assert STATE_FILE == ".worktrees/.agent-fleet.json"


def test_worktrees_dir_constant():
    """Worktrees directory should be .worktrees"""
    assert WORKTREES_DIR == ".worktrees"


def test_state_structure_spec():
    """State file should have workspaces dict with specific fields"""
    # This documents the expected state structure
    state = {
        "workspaces": {
            "agent-20250116-120000": {
                "id": "20250116-120000",
                "description": "Task description",
                "created": "2025-01-16T12:00:00",
                "path": ".worktrees/agent-20250116-120000",
                "agent": "claude-code",
            }
        }
    }

    # Verify structure
    assert "workspaces" in state
    assert isinstance(state["workspaces"], dict)

    workspace = state["workspaces"]["agent-20250116-120000"]
    assert "id" in workspace
    assert "description" in workspace
    assert "created" in workspace
    assert "path" in workspace
    assert "agent" in workspace


def test_empty_state_initialization():
    """Empty state should have empty workspaces dict"""
    state = {"workspaces": {}}
    assert isinstance(state["workspaces"], dict)
    assert len(state["workspaces"]) == 0


def test_ensure_worktrees_dir_creates_directory(tmp_path):
    """Should create .worktrees directory if it doesn't exist"""
    repo_root = tmp_path / "test-repo"
    repo_root.mkdir()

    worktrees = ensure_worktrees_dir(repo_root)

    assert worktrees.exists()
    assert worktrees.is_dir()
    assert worktrees == repo_root / WORKTREES_DIR


def test_ensure_worktrees_dir_idempotent(tmp_path):
    """Should not fail if directory already exists"""
    repo_root = tmp_path / "test-repo"
    repo_root.mkdir()

    # Create it once
    worktrees1 = ensure_worktrees_dir(repo_root)

    # Create it again
    worktrees2 = ensure_worktrees_dir(repo_root)

    assert worktrees1 == worktrees2
    assert worktrees1.exists()


def test_state_workspace_path_relative():
    """Workspace path in state should be relative to repo root"""
    # This is a spec test documenting the expected behavior
    workspace_path = ".worktrees/agent-20250116-120000"

    assert not workspace_path.startswith("/")  # Not absolute
    assert workspace_path.startswith(WORKTREES_DIR)


# =============================================================================
# AI-SEARCH: ENTRY
# Entry Point
# =============================================================================

if __name__ == "__main__":
    app()
