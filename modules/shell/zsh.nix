{
  config,
  options,
  pkgs,
  lib,
  ...
}:
with lib;
with lib.my;
let
  cfg = config.modules.shell.zsh;
  inherit (config.dotfiles) configDir;
  
  # Define znap and plugin configuration
  znapPlugins = [
    "junegunn/fzf shell/{key-bindings,completion}.zsh"
    "jeffreytse/zsh-vi-mode"
    "zdharma-continuum/fast-syntax-highlighting"
    "zsh-users/zsh-completions"
    "zsh-users/zsh-autosuggestions"
    "zsh-users/zsh-history-substring-search"
    "atuinsh/atuin"
    "hlissner/zsh-autopair autopair.zsh"
  ];
  
  # Generate znap plugin loading commands
  pluginCommands = concatMapStringsSep "\n" (plugin: "znap source ${plugin}") znapPlugins;
  
  # Znap initialization script
  znapInit = ''
    # Initialize znap (managed by Nix)
    ZNAP_DIR="${pkgs.zsh-snap}/share/zsh-snap"
    source "$ZNAP_DIR/znap.zsh"
    
    # Configure znap
    zstyle ':znap:*' auto-compile no
    zstyle ':znap:*' repos-dir "$XDG_DATA_HOME/zsh"
    
    # Load plugins
    ${pluginCommands}
    
    # Load prompt (deferred)
    znap prompt romkatv/powerlevel10k
    
    # Compile zsh files for performance
    znap compile $ZDOTDIR/{.zshrc,*.zsh} 2>/dev/null || true
  '';
  
  # Package for zsh-snap
  zsh-snap = pkgs.stdenv.mkDerivation rec {
    pname = "zsh-snap";
    version = "unstable-2024-12-01";
    
    src = pkgs.fetchFromGitHub {
      owner = "marlonrichert";
      repo = "zsh-snap";
      rev = "25754a45d9ceafe6d7d082c9ebe40a08cb85a4f0";  # Latest commit as of Dec 2024
      sha256 = "sha256-iunAF4hXQ5vC5u3nXPB+q1xLWaFsYKcbsGijrDHGVQo=";
    };
    
    installPhase = ''
      mkdir -p $out/share/zsh-snap
      cp -r * $out/share/zsh-snap/
    '';
  };
in
{
  options.modules.shell.zsh = with types; {
    enable = mkBoolOpt false;

    aliases = mkOpt (attrsOf (either str path)) { };

    rcInit = mkOpt' lines "" ''
      Zsh lines to be written to $XDG_CONFIG_HOME/zsh/extra.zshrc and sourced by
      $XDG_CONFIG_HOME/zsh/.zshrc
    '';
    envInit = mkOpt' lines "" ''
      Zsh lines to be written to $XDG_CONFIG_HOME/zsh/extra.zshenv and sourced
      by $XDG_CONFIG_HOME/zsh/.zshenv
    '';

    rcFiles = mkOpt (listOf (either str path)) [ ];
    envFiles = mkOpt (listOf (either str path)) [ ];
  };

  config = mkIf cfg.enable {
    users.defaultUserShell = pkgs.zsh;

    programs.zsh = {
      enable = true;
      enableCompletion = true;
      # I init completion myself, because enableGlobalCompInit initializes it
      # too soon, which means commands initialized later in my config won't get
      # completion, and running compinit twice is slow.
      enableGlobalCompInit = false;
      promptInit = "";
    };

    # Create symlinks for zsh configuration files in home directory
    home.file = {
      ".zshenv".source = "${config.dotfiles.configDir}/zsh/.zshenv";
      ".zshrc".text = ''
        #!/usr/bin/env zsh
        # Ensure essential environment variables are set
        export XDG_CONFIG_HOME="''${XDG_CONFIG_HOME:-$HOME/.config}"
        export XDG_DATA_HOME="''${XDG_DATA_HOME:-$HOME/.local/share}"
        export XDG_CACHE_HOME="''${XDG_CACHE_HOME:-$HOME/.cache}"
        export ZDOTDIR="''${ZDOTDIR:-$XDG_CONFIG_HOME/zsh}"
        export ZSH_CACHE="''${ZSH_CACHE:-$XDG_CACHE_HOME/zsh}"
        
        # Helper functions
        function _source {
          [[ -f "$1" ]] && source "$1"
        }
        
        function _cache {
          local cache_dir="$XDG_CACHE_HOME/zsh"
          local cache_file="$cache_dir/$1.zsh"
          
          if [[ ! -f "$cache_file" ]] || [[ "$commands[$1]" -nt "$cache_file" ]]; then
            mkdir -p "$cache_dir"
            "$@" > "$cache_file"
          fi
          source "$cache_file"
        }
        
        # Source configuration
        source $ZDOTDIR/config.zsh
        
        ${znapInit}
        
        # Load p10k config if it exists
        [[ -f $ZDOTDIR/.p10k.zsh ]] && source $ZDOTDIR/.p10k.zsh
        
        ## Bootstrap interactive sessions
        if [[ $TERM != dumb ]]; then
          autoload -Uz compinit && compinit -i -u -d $ZSH_CACHE/zcompdump
        
          source $ZDOTDIR/keybinds.zsh
          source $ZDOTDIR/completion.zsh
          source $ZDOTDIR/aliases.zsh
        
          # Auto-generated by nixos
          _source $ZDOTDIR/extra.zshrc
          # If you have host-local configuration, put it here
          _source $ZDOTDIR/local.zshrc
        
          # Initialize zoxide with caching
          if (( $+commands[zoxide] )); then
            _cache zoxide init zsh
          fi
          
          # Initialize autopair
          if (( $+functions[autopair-init] )); then
            autopair-init
          fi
        fi
      '';
    };

    user.packages = with pkgs; [
      zsh
      zsh-snap  # Our custom package
      unstable.atuin
      bat
      btop
      eza
      fcp
      fd
      unstable.fzf
      gh
      git-lfs
      glow
      (ripgrep.override { withPCRE2 = true; })
      lazygit
      neovim
      procs
      delta
      hyperfine
      just
      sd
      unstable.yazi
      zoxide
    ];

    env = {
      ZDOTDIR = "$XDG_CONFIG_HOME/zsh";
      ZSH_CACHE = "$XDG_CACHE_HOME/zsh";
    };

    home.configFile = {
      # Write it recursively so other modules can write files to it
      "zsh" = {
        source = "${configDir}/zsh";
        recursive = true;
      };

      # Why am I creating extra.zsh{rc,env} when I could be using extraInit?
      # Because extraInit generates those files in /etc/profile, and mine just
      # write the files to ~/.config/zsh; where it's easier to edit and tweak
      # them in case of issues or when experimenting.
      "zsh/extra.zshrc".text =
        let
          aliasLines = mapAttrsToList (n: v: ''alias ${n}="${v}"'') cfg.aliases;
        in
        ''
          # This file was autogenerated, do not edit it!
          ${concatStringsSep "\n" aliasLines}
          ${concatMapStrings (path: ''
            source '${path}'
          '') cfg.rcFiles}
          ${cfg.rcInit}
        '';

      "zsh/extra.zshenv".text = ''
        # This file is autogenerated, do not edit it!
        ${concatMapStrings (path: ''
          source '${path}'
        '') cfg.envFiles}
        ${cfg.envInit}
      '';
    };

    modules.shell.zsh.aliases = {
      # aliases
      cd = "z";
      cdi = "zi";

      chmod = "chmod -v";
      cp = "cp -iv";
      ln = "ln -v";
      mkdir = "mkdir -vp";
      mv = "mv -iv";
      rm = "rm -v";
      rmdir = "rmdir -v";

      rst = "exec $SHELL";
      sudo = "sudo ";
      su = "sudo su";

      # nix
      scrap = "nix-collect-garbage -d && sudo nix-collect-garbage -d";
      rebuild = "sudo nixos-rebuild switch";
      reflake = "sudo nixos-rebuild switch --recreate-lock-file";
      nix-clean = "nix-collect-garbage -d";

      # ls
      ls = "eza --group-directories-first --git";
      la = "ll -a";
      ll = "ls -l";
      l = "ls -1A";

      # ripgrep
      rg = "rg --color=auto";
      rga = "rg -uuu";
      rgf = "rg --files";

      # other
      q = "exit";
      c = "clear";
      cat = "bat --style=plain";
      e = "$EDITOR";
      v = "$EDITOR";
      vi = "$EDITOR";
      vim = "$EDITOR";
      nvim = "$EDITOR";
      http = "xh";
      dsize = "du -hs";
      rcp = "rsync -avh --progress";
      weather = "curl -s 'wttr.in/Ft+Worth?m&format=3'";

      # taskwarrior
      t = "task";
      ta = "task add";
      td = "task done";
      tm = "task modify";
      ts = "task sync";
      to = "taskopen";
      tn = "task-note";
      tp = "task +PENDING";
      tb = "task burndown.daily";
      tsw = "task start";
      tst = "task stop";
      bug = "taskopen -n";
      td1 = "task done +1";
      td2 = "task done +2";
      td3 = "task done +3";
      td4 = "task done +4";

      # docker-compose
      dcup = "docker-compose up -d";
      dcdw = "docker-compose down";
      dcre = "docker-compose restart";
      dclo = "docker-compose logs -f";
    };

    modules.shell.zsh.rcFiles = [ ];
  };
}