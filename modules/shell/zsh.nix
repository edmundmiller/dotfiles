{
  config,
  options,
  pkgs,
  lib,
  isDarwin,
  ...
}:
with lib;
with lib.my;
let
  cfg = config.modules.shell.zsh;
  inherit (config.dotfiles) configDir;
in
{
  options.modules.shell.zsh = with types; {
    enable = mkBoolOpt false;

    rcInit = mkOpt' lines "" ''
      Zsh lines to be written to $XDG_CONFIG_HOME/zsh/extra.zshrc and sourced by
      $XDG_CONFIG_HOME/zsh/.zshrc
    '';
    envInit = mkOpt' lines "" ''
      Zsh lines to be written to $XDG_CONFIG_HOME/zsh/extra.zshenv and sourced
      by $XDG_CONFIG_HOME/zsh/.zshenv
    '';

    rcFiles = mkOpt (listOf (either str path)) [ ];
    envFiles = mkOpt (listOf (either str path)) [ ];
  };

  config = mkIf cfg.enable (mkMerge [
    {
      # Add zsh to available shells
      environment.shells = [ pkgs.zsh ];

      # Enable zsh at system level - this creates /etc/zshrc that loads nix-darwin environment
      programs.zsh = {
        enable = true;
        # I init completion myself, because enableGlobalCompInit initializes it
        # too soon, which means commands initialized later in my config won't get
        # completion, and running compinit twice is slow.
        enableCompletion = true;
        enableGlobalCompInit = false;
        # I configure the prompt myself, so disable the default.
        promptInit = "";
      };

      user.packages = with pkgs; [
        zsh
        antidote
        unstable.atuin
        bat
        btop
        eza
        fd
        unstable.fzf
        gh
        git-lfs
        glow
        (ripgrep.override { withPCRE2 = true; })
        lazygit
        neovim
        procs
        difftastic
        hyperfine
        just
        sd
        unstable.yazi
        zoxide
      ];

      env = {
        ZDOTDIR = "$XDG_CONFIG_HOME/zsh";
        ZSH_CACHE = "$XDG_CACHE_HOME/zsh";
        PATH = [ "$DOTFILES_BIN" ];
      };

      environment.shellAliases = {
        # zoxide
        cd = "z";
        cdi = "zi";

        # file operations
        chmod = "chmod -v";
        cp = "cp -iv";
        ln = "ln -v";
        mkdir = "mkdir -vp";
        mv = "mv -iv";
        rm = "rm -v";
        rmdir = "rmdir -v";

        # shell
        rst = "exec $SHELL";
        sudo = "sudo ";
        su = "sudo su";

        # nix
        scrap = "nix-collect-garbage -d && sudo nix-collect-garbage -d";
        rebuild = "sudo nixos-rebuild switch";
        reflake = "sudo nixos-rebuild switch --recreate-lock-file";
        nix-clean = "nix-collect-garbage -d";

        # ls (eza)
        ls = "eza --group-directories-first --git";
        la = "ll -a";
        ll = "ls -l";
        l = "ls -1A";

        # ripgrep
        rg = "rg --color=auto";
        rga = "rg -uuu";
        rgf = "rg --files";

        # misc
        q = "exit";
        c = "clear";
        cat = "bat --style=plain";
        e = "$EDITOR";
        http = "xh";
        dsize = "du -hs";
        # rcp: rsync that respects gitignore
        # -a = archive mode (-rlptgoD: recursive, symlinks, permissions, times, group, owner)
        # -z = compression
        # -P = --partial --progress (show progress, keep partial files)
        # -J = omit symlink mtimes (prevents errors)
        # --include=.git/ = include git directories
        # --filter = respect .gitignore files
        rcp = "rsync -azPJ --include=.git/ --filter=':- .gitignore' --filter=':- $XDG_CONFIG_HOME/git/ignore'";
        weather = "curl -s 'wttr.in/Ft+Worth?m&format=3'";

        # taskwarrior
        t = "task";
        ta = "task add";
        td = "task done";
        tm = "task modify";
        ts = "task sync";
        to = "taskopen";
        tn = "task-note";
        tp = "task +PENDING";
        tb = "task burndown.daily";
        tsw = "task start";
        tst = "task stop";
        bug = "taskopen -n";
        td1 = "task done +1";
        td2 = "task done +2";
        td3 = "task done +3";
        td4 = "task done +4";

        # docker-compose
        dcup = "docker-compose up -d";
        dcdw = "docker-compose down";
        dcre = "docker-compose restart";
        dclo = "docker-compose logs -f";
      };

      home.configFile = {
        # Link zsh directory recursively, so other modules (or the user) can
        # write files there later.
        "zsh" = {
          source = "${configDir}/zsh";
          recursive = true;
        };

        # Why extra.zsh{rc,env} when I could be using extraInit? Because extraInit
        # generates those files in /etc/profile, and mine just write the files to
        # ~/.config/zsh; where it's easier to edit and tweak them in case of
        # issues or when experimenting.
        "zsh/extra.zshrc".text = ''
          # This file was autogenerated, do not edit it!
          ${concatMapStrings (path: ''
            source '${path}'
          '') cfg.rcFiles}
          ${cfg.rcInit}
        '';

        "zsh/extra.zshenv".text = ''
          # This file is autogenerated, do not edit it!
          ${concatMapStrings (path: ''
            source '${path}'
          '') cfg.envFiles}
          ${cfg.envInit}
        '';
      };
    }

    # Darwin-only: nix-darwin puts aliases in /etc/zprofile (login shells only), not /etc/zshrc.
    # This means non-login interactive shells miss them. Load them here too.
    (mkIf isDarwin {
      programs.zsh.interactiveShellInit = config.system.build.setAliases.text;
    })

    # NixOS-only shell configuration
    (mkIf (!isDarwin) {
      users.defaultUserShell = pkgs.zsh;
    })
  ]);
}
