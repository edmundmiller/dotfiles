#!/bin/bash
#
# Todo.sh Format Action - Comprehensive formatting for todo.txt files
#
# Usage: todo.sh format [options]
#
# This action provides a clean interface to the todo.txt formatter,
# supporting both comprehensive and simple formatting modes.
#

set -euo pipefail

# Action description for todo.sh help system
ACTION="format"
if [[ "${1:-}" == "usage" ]]; then
    echo "    format [OPTIONS]:"
    echo "        Format and normalize todo.txt and done.txt files"
    echo "        OPTIONS:"
    echo "          --simple       Use simple formatter (faster, fewer features)"
    echo "          --dry-run|-n   Preview changes without applying them"
    echo "          --verbose|-v   Show detailed processing information"
    echo "          --quiet|-q     Suppress non-essential output"
    echo "          --check-only   Validate and report without making changes"
    echo "          --help|-h      Show detailed help"
    echo ""
    exit 0
fi

# Skip the action name argument if it was passed by todo.sh
if [[ "${1:-}" == "format" ]]; then
    shift
fi

# Get the directory where this script resides (should be ~/.todo.actions.d)
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
RESET='\033[0m'

echo_info() { echo -e "${GREEN}INFO:${RESET} $*" >&2; }
echo_warning() { echo -e "${YELLOW}WARNING:${RESET} $*" >&2; }
echo_error() { echo -e "${RED}ERROR:${RESET} $*" >&2; }

# Show detailed help
show_help() {
    cat << 'EOF'
Todo.sh Format Action - Comprehensive formatting for todo.txt files

USAGE:
    todo.sh format [OPTIONS]

DESCRIPTION:
    Formats and normalizes your todo.txt and done.txt files according to the
    official specification. Uses a robust Go-based formatter when available,
    with fallback to bash-based formatters. Fixes common issues like priority
    placement, date formats, context/project positioning, and metadata spacing.

OPTIONS:
    --simple            Use simple formatter (faster, fewer features)
    --dry-run, -n       Preview changes without applying them  
    --verbose, -v       Show detailed processing information
    --quiet, -q         Suppress non-essential output
    --check-only        Validate and report without making changes
    --help, -h          Show this help message

FORMATTING FEATURES:
    ✓ Priority validation and placement: (A) at start of line
    ✓ Date normalization: YYYY-MM-DD format for all dates
    ✓ Context (@) and project (+) repositioning after description
    ✓ Metadata spacing: key:value format standardization  
    ✓ Completed task validation: proper x YYYY-MM-DD format
    ✓ Comment and blank line preservation
    ✓ Section-based sorting (comprehensive mode)
    ✓ Atomic file updates with timestamped backups
    ✓ File locking to prevent concurrent modifications (comprehensive mode)

MODES:
    Comprehensive (default): Full-featured formatter with advanced validation,
                           section-aware sorting, and comprehensive statistics.
                           
    Simple (--simple):     Lightweight formatter focusing on the most common
                           formatting issues. Faster but fewer features.

EXAMPLES:
    todo.sh format                    # Format using comprehensive mode
    todo.sh format --simple           # Use simple formatter  
    todo.sh format --dry-run          # Preview changes
    todo.sh format --simple -n        # Simple dry-run
    todo.sh format --verbose          # Detailed output
    todo.sh format --check-only       # Validate without changes

EXIT CODES:
    0    Success: Files processed and updated (or confirmed clean)
    1    Error: Processing failed, files not updated  
    2    Check mode: Issues found but no changes made

SPECIFICATION:
    Follows the official todo.txt specification:
    https://github.com/todotxt/todo.txt

EOF
}

# Parse arguments
USE_SIMPLE=false
FORMATTER_ARGS=()

while [[ $# -gt 0 ]]; do
    case $1 in
        --simple)
            USE_SIMPLE=true
            shift
            ;;
        --dry-run|-n)
            FORMATTER_ARGS+=("--dry-run")
            shift
            ;;
        --verbose|-v)
            FORMATTER_ARGS+=("--verbose")
            shift
            ;;
        --quiet|-q)
            FORMATTER_ARGS+=("--quiet")
            shift
            ;;
        --check-only)
            FORMATTER_ARGS+=("--check-only")
            shift
            ;;
        --help|-h)
            show_help
            exit 0
            ;;
        *)
            echo_error "Unknown option: $1"
            echo "Use 'todo.sh format --help' for usage information."
            exit 1
            ;;
    esac
done

# Determine which formatter to use and build command
GO_FORMATTER="$SCRIPT_DIR/todotxtfmt"

if [[ $USE_SIMPLE == true ]]; then
    # Use simple formatter if explicitly requested
    FORMATTER_CMD="$SCRIPT_DIR/formatter-simple"
    
    # Convert comprehensive formatter args to simple formatter args
    DRY_RUN="false"
    for arg in "${FORMATTER_ARGS[@]:-}"; do
        case "$arg" in
            --dry-run) DRY_RUN="true" ;;
            --verbose) echo_warning "Simple formatter doesn't support --verbose, ignoring" ;;
            --quiet) echo_warning "Simple formatter doesn't support --quiet, ignoring" ;;
            --check-only) echo_warning "Simple formatter doesn't support --check-only, using --dry-run instead"; DRY_RUN="true" ;;
        esac
    done
    
    # Simple formatter takes positional arguments
    FORMATTER_CMD="$FORMATTER_CMD \"\$TODO_FILE\" \"\$DONE_FILE\" \"$DRY_RUN\""
elif [[ -x "$GO_FORMATTER" ]]; then
    # Use Go-based formatter if available (preferred)
    FORMATTER_CMD="$GO_FORMATTER"
    
    # Add arguments compatible with Go formatter
    for arg in "${FORMATTER_ARGS[@]:-}"; do
        case "$arg" in
            --dry-run) FORMATTER_CMD="$FORMATTER_CMD --dry-run" ;;
            --verbose) FORMATTER_CMD="$FORMATTER_CMD --verbose" ;;
            --quiet) FORMATTER_CMD="$FORMATTER_CMD --quiet" ;;
            --check-only) FORMATTER_CMD="$FORMATTER_CMD --dry-run --diff" ;;
        esac
    done
    
    # Go formatter uses environment variables automatically
    # No need to explicitly pass TODO_FILE
else
    # Fallback to bash comprehensive formatter
    FORMATTER_CMD="$SCRIPT_DIR/formatter"
    
    # Add todo/done file paths
    FORMATTER_CMD="$FORMATTER_CMD --todo \"\$TODO_FILE\" --done \"\$DONE_FILE\""
    
    # Add other arguments
    for arg in "${FORMATTER_ARGS[@]:-}"; do
        FORMATTER_CMD="$FORMATTER_CMD $arg"
    done
fi

# Check that the selected formatter exists
FORMATTER_PATH="$SCRIPT_DIR/formatter"
FORMATTER_SIMPLE_PATH="$SCRIPT_DIR/formatter-simple"

if [[ $USE_SIMPLE == true ]]; then
    if [[ ! -x "$FORMATTER_SIMPLE_PATH" ]]; then
        echo_error "Simple formatter not found or not executable: $FORMATTER_SIMPLE_PATH"
        exit 1
    fi
elif [[ -x "$GO_FORMATTER" ]]; then
    # Go formatter is available and will be used
    true
else
    if [[ ! -x "$FORMATTER_PATH" ]]; then
        echo_error "No formatter available. Need either:"
        echo_error "  - Go formatter: $GO_FORMATTER"
        echo_error "  - Bash formatter: $FORMATTER_PATH"
        exit 1
    fi
fi

# Inform user which formatter is being used
if [[ $USE_SIMPLE == true ]]; then
    echo_info "Using simple formatter"
elif [[ -x "$GO_FORMATTER" ]]; then
    echo_info "Using Go-based formatter (preferred)"
else
    echo_info "Using bash comprehensive formatter (fallback)"
fi

# Execute the formatter
eval "$FORMATTER_CMD"