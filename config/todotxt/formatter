#!/bin/bash
#
# Todo.txt Formatter - Comprehensive todo.txt and done.txt formatting tool
# 
# Validates and reformats todo.txt files according to the official specification:
# https://github.com/todotxt/todo.txt
#
# Features:
# - Validates and fixes priority placement and format
# - Normalizes date formats (creation and completion dates)
# - Fixes context (@) and project (+) placement
# - Standardizes metadata spacing (due:, t:, rec:, etc.)
# - Preserves comments and blank lines
# - Creates timestamped backups
# - Provides detailed diffs and statistics
# - Supports dry-run mode
# - Handles file locking to prevent concurrent edits
#
# Usage: formatter [options] [--todo PATH] [--done PATH]
#
# Copyright (c) 2025 - MIT License

set -euo pipefail

# Default configuration
SCRIPT_NAME="$(basename "$0")"
VERSION="1.0.0"
DEFAULT_TODO_PATH="$HOME/Documents/todo/todo.txt"
DEFAULT_DONE_PATH="$HOME/Documents/todo/done.txt"

# Command line options with defaults
DRY_RUN=false
VERBOSE=false
QUIET=false
TODO_PATH=""
DONE_PATH=""
BACKUP_DIR=""
ASSUME_TODAY_COMPLETION=false
NO_SORT=false
CHECK_ONLY=false
NO_COLOR=false
SHOW_HELP=false

# Global state
TEMP_DIR=""
LOCK_FDS=()
EXIT_CODE=0
STATS_TOTAL_LINES=0
STATS_TASKS_PROCESSED=0
STATS_COMMENTS_PRESERVED=0
STATS_BLANKS_PRESERVED=0
STATS_INCOMPLETE_CHANGED=0
STATS_COMPLETED_CHANGED=0
STATS_PRIORITIES_FIXED=0
STATS_DATES_NORMALIZED=0
STATS_AMBIGUOUS_DATES=0
STATS_CONTEXTS_REPOSITIONED=0
STATS_METADATA_FIXED=0
STATS_PRIORITIES_REMOVED=0
STATS_ERRORS=0
STATS_WARNINGS=0

# Colors for output (if enabled)
RED=""
GREEN=""
YELLOW=""
BLUE=""
CYAN=""
RESET=""

# Initialize colors based on terminal capability
init_colors() {
    if [[ $NO_COLOR != true ]] && [[ -t 1 ]] && command -v tput >/dev/null 2>&1; then
        RED=$(tput setaf 1 2>/dev/null || true)
        GREEN=$(tput setaf 2 2>/dev/null || true)
        YELLOW=$(tput setaf 3 2>/dev/null || true)
        BLUE=$(tput setaf 4 2>/dev/null || true)
        CYAN=$(tput setaf 6 2>/dev/null || true)
        RESET=$(tput sgr0 2>/dev/null || true)
    fi
}

# Logging functions
log_error() {
    echo "${RED}ERROR: $*${RESET}" >&2
    ((STATS_ERRORS++))
}

log_warning() {
    echo "${YELLOW}WARNING: $*${RESET}" >&2
    ((STATS_WARNINGS++))
}

log_info() {
    if [[ $QUIET != true ]]; then
        echo "${GREEN}INFO: $*${RESET}" >&2
    fi
}

log_verbose() {
    if [[ $VERBOSE == true ]]; then
        echo "${CYAN}VERBOSE: $*${RESET}" >&2
    fi
}

# Help text
show_help() {
    cat << 'EOF'
Todo.txt Formatter - Comprehensive formatting tool for todo.txt files

USAGE:
    formatter [OPTIONS] [--todo PATH] [--done PATH]

DESCRIPTION:
    Validates and reformats todo.txt and done.txt files according to the official
    specification. Fixes priority placement, normalizes dates, standardizes
    spacing, and preserves comments and structure.

OPTIONS:
    -n, --dry-run               Preview changes without applying them
    -v, --verbose               Print detailed processing information
    -q, --quiet                 Suppress non-essential output
    --todo PATH                 Path to todo.txt file (default: ~/Documents/todo/todo.txt)
    --done PATH                 Path to done.txt file (default: ~/Documents/todo/done.txt)
    --backup-dir DIR            Directory for backup files (default: alongside originals)
    --assume-today-completion   Fill missing completion dates with today's date
    --no-sort                   Skip sorting tasks within sections
    --check-only                Validate and report without making changes
    --no-color                  Disable colored output
    -h, --help                  Show this help message

FEATURES:
    ✓ Priority validation and placement: (A) at start of line
    ✓ Date normalization: YYYY-MM-DD format for all dates
    ✓ Context (@) and project (+) repositioning after description
    ✓ Metadata spacing: key:value format standardization
    ✓ Completed task validation: proper x YYYY-MM-DD format
    ✓ Comment and blank line preservation
    ✓ Section-based sorting (preserves comment structure)
    ✓ Atomic file updates with timestamped backups
    ✓ File locking to prevent concurrent modifications

EXAMPLES:
    formatter                              # Format default files
    formatter --dry-run                    # Preview changes
    formatter --verbose --check-only       # Detailed validation report
    formatter --todo ~/custom/todo.txt     # Format custom file
    formatter --assume-today-completion    # Fix missing completion dates

EXIT CODES:
    0    Success: Files processed and updated (or confirmed clean)
    1    Error: Processing failed, files not updated
    2    Check mode: Issues found but no changes made

SPECIFICATION:
    Follows the official todo.txt specification:
    https://github.com/todotxt/todo.txt

EOF
}

# Parse command line arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -n|--dry-run)
                DRY_RUN=true
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -q|--quiet)
                QUIET=true
                shift
                ;;
            --todo)
                if [[ $# -lt 2 ]]; then
                    log_error "--todo requires a path argument"
                    exit 1
                fi
                TODO_PATH="$2"
                shift 2
                ;;
            --done)
                if [[ $# -lt 2 ]]; then
                    log_error "--done requires a path argument"
                    exit 1
                fi
                DONE_PATH="$2"
                shift 2
                ;;
            --backup-dir)
                if [[ $# -lt 2 ]]; then
                    log_error "--backup-dir requires a path argument"
                    exit 1
                fi
                BACKUP_DIR="$2"
                shift 2
                ;;
            --assume-today-completion)
                ASSUME_TODAY_COMPLETION=true
                shift
                ;;
            --no-sort)
                NO_SORT=true
                shift
                ;;
            --check-only)
                CHECK_ONLY=true
                shift
                ;;
            --no-color)
                NO_COLOR=true
                shift
                ;;
            -h|--help)
                SHOW_HELP=true
                shift
                ;;
            -*)
                log_error "Unknown option: $1"
                exit 1
                ;;
            *)
                log_error "Unexpected argument: $1"
                exit 1
                ;;
        esac
    done
}

# Path resolution and validation
resolve_path() {
    local path="$1"
    # Handle tilde expansion
    if [[ $path =~ ^~/ ]]; then
        path="${HOME}/${path#~/}"
    elif [[ $path == "~" ]]; then
        path="$HOME"
    fi
    # Convert to absolute path
    if [[ $path != /* ]]; then
        path="$(pwd)/$path"
    fi
    echo "$path"
}

validate_file_access() {
    local file_path="$1"
    local file_type="$2"
    
    log_verbose "Validating access to $file_type: $file_path"
    
    if [[ ! -e "$file_path" ]]; then
        log_warning "$file_type file does not exist: $file_path (will be created if needed)"
        # Check if directory exists and is writable
        local dir_path
        dir_path="$(dirname "$file_path")"
        if [[ ! -d "$dir_path" ]]; then
            log_error "Directory does not exist for $file_type: $dir_path"
            return 1
        fi
        if [[ ! -w "$dir_path" ]]; then
            log_error "Directory is not writable for $file_type: $dir_path"
            return 1
        fi
    else
        if [[ ! -r "$file_path" ]]; then
            log_error "$file_type file is not readable: $file_path"
            return 1
        fi
        if [[ ! -w "$file_path" ]]; then
            log_error "$file_type file is not writable: $file_path"
            return 1
        fi
    fi
    return 0
}

# File locking implementation
acquire_lock() {
    local file_path="$1"
    local lock_path="${file_path}.lock"
    local lock_fd
    
    log_verbose "Acquiring lock for: $file_path"
    
    # Try to use flock if available
    if command -v flock >/dev/null 2>&1; then
        exec {lock_fd}>"$lock_path"
        if ! flock -n "$lock_fd" 2>/dev/null; then
            log_error "Could not acquire lock for $file_path (already in use?)"
            exec {lock_fd}>&-
            return 1
        fi
        LOCK_FDS+=("$lock_fd:$lock_path")
    else
        # Fallback to lockfile creation with noclobber
        if ! (set -C; echo $$ > "$lock_path") 2>/dev/null; then
            log_error "Could not acquire lock for $file_path (already in use?)"
            return 1
        fi
        LOCK_FDS+=(":$lock_path")
    fi
    
    log_verbose "Lock acquired: $lock_path"
    return 0
}

# Release all locks
cleanup_locks() {
    log_verbose "Cleaning up locks..."
    for lock_entry in "${LOCK_FDS[@]:-}"; do
        local lock_fd="${lock_entry%%:*}"
        local lock_path="${lock_entry#*:}"
        
        if [[ -n "$lock_fd" ]]; then
            exec {lock_fd}>&- 2>/dev/null || true
        fi
        
        if [[ -f "$lock_path" ]]; then
            rm -f "$lock_path" 2>/dev/null || true
            log_verbose "Released lock: $lock_path"
        fi
    done
    LOCK_FDS=()
}

# Create temporary directory
init_temp_dir() {
    TEMP_DIR=$(mktemp -d -t "${SCRIPT_NAME}.XXXXXXXX")
    log_verbose "Created temp directory: $TEMP_DIR"
}

# Cleanup function
cleanup() {
    local exit_code=$?
    log_verbose "Cleanup started (exit code: $exit_code)"
    
    cleanup_locks
    
    if [[ -n "$TEMP_DIR" && -d "$TEMP_DIR" ]]; then
        rm -rf "$TEMP_DIR" 2>/dev/null || true
        log_verbose "Removed temp directory: $TEMP_DIR"
    fi
    
    exit $exit_code
}

# Set up signal handling
trap cleanup EXIT INT TERM

# Create backup file
create_backup() {
    local file_path="$1"
    local backup_dir="${2:-$(dirname "$file_path")}"
    
    if [[ ! -f "$file_path" ]]; then
        log_verbose "No backup needed for non-existent file: $file_path"
        return 0
    fi
    
    local filename
    filename="$(basename "$file_path")"
    local timestamp
    timestamp="$(date '+%Y%m%d-%H%M%S')"
    local backup_path="$backup_dir/${filename}.$timestamp.bak"
    
    log_verbose "Creating backup: $backup_path"
    
    if ! cp "$file_path" "$backup_path" 2>/dev/null; then
        log_error "Failed to create backup: $backup_path"
        return 1
    fi
    
    log_info "Backup created: $backup_path"
    return 0
}

# Get current date in YYYY-MM-DD format
get_current_date() {
    date '+%Y-%m-%d'
}

# AWK script for parsing and normalizing todo.txt lines
get_awk_normalizer() {
    cat << 'EOF'
BEGIN {
    # Initialize statistics
    total_lines = 0
    tasks_processed = 0
    comments_preserved = 0
    blanks_preserved = 0
    incomplete_changed = 0
    completed_changed = 0
    priorities_fixed = 0
    dates_normalized = 0
    ambiguous_dates = 0
    contexts_repositioned = 0
    metadata_fixed = 0
    priorities_removed = 0
    errors = 0
    warnings = 0
    
    # Current date for completion date fixes
    current_date = ENVIRON["CURRENT_DATE"]
    assume_today = (ENVIRON["ASSUME_TODAY"] == "true")
    file_type = ENVIRON["FILE_TYPE"]  # "todo" or "done"
    
    # Section tracking for sorting
    section_id = 0
    in_task_section = 0
}

# Utility functions
function log_change(line_num, change_type, original, normalized, description) {
    printf "CHANGE|%d|%s|%s|%s|%s\n", line_num, change_type, original, normalized, description > "/dev/stderr"
}

function log_stats(key, value) {
    printf "STAT|%s|%s\n", key, value > "/dev/stderr"
}

function is_blank_line(line) {
    return match(line, /^[[:space:]]*$/)
}

function is_comment_line(line) {
    return match(line, /^[[:space:]]*#/)
}

function is_completed_task(line) {
    return match(line, /^x[[:space:]]/)
}

function normalize_date(date_str) {
    # Handle YYYY-MM-DD (already correct)
    if (match(date_str, /^[0-9]{4}-[0-9]{1,2}-[0-9]{1,2}$/)) {
        split(date_str, parts, "-")
        return sprintf("%04d-%02d-%02d", parts[1], parts[2], parts[3])
    }
    
    # Handle YYYYMMDD
    if (match(date_str, /^[0-9]{8}$/)) {
        year = substr(date_str, 1, 4)
        month = substr(date_str, 5, 2)
        day = substr(date_str, 7, 2)
        return sprintf("%04d-%02d-%02d", year, month, day)
    }
    
    # Handle YYYY.MM.DD and YYYY/MM/DD
    if (match(date_str, /^[0-9]{4}[.\/][0-9]{1,2}[.\/][0-9]{1,2}$/)) {
        gsub(/[.\/]/, "-", date_str)
        split(date_str, parts, "-")
        return sprintf("%04d-%02d-%02d", parts[1], parts[2], parts[3])
    }
    
    # Ambiguous or invalid format
    return ""
}

function is_valid_date(date_str) {
    if (!match(date_str, /^[0-9]{4}-[0-9]{2}-[0-9]{2}$/)) {
        return 0
    }
    split(date_str, parts, "-")
    year = parts[1] + 0
    month = parts[2] + 0
    day = parts[3] + 0
    
    if (year < 1900 || year > 2100) return 0
    if (month < 1 || month > 12) return 0
    if (day < 1 || day > 31) return 0
    
    return 1
}

function extract_priority(line) {
    if (match(line, /\([A-Za-z]\)/)) {
        priority_match = substr(line, RSTART, RLENGTH)
        priority_letter = toupper(substr(priority_match, 2, 1))
        return "(" priority_letter ")"
    }
    return ""
}

function remove_priority(line, priority) {
    if (priority != "") {
        # Remove the first occurrence of priority
        sub(/\([A-Za-z]\)[[:space:]]*/, "", line)
    }
    return line
}

function extract_contexts_projects(line) {
    contexts = ""
    projects = ""
    n_contexts = 0
    n_projects = 0
    
    # Find all contexts and projects
    remaining = line
    while (match(remaining, /@[^[:space:]@]+|\+[^[:space:]\+]+/)) {
        token = substr(remaining, RSTART, RLENGTH)
        if (substr(token, 1, 1) == "@" && !match(token, /@.*@/)) {
            # It's a context (not an email)
            contexts = contexts (n_contexts > 0 ? " " : "") token
            n_contexts++
        } else if (substr(token, 1, 1) == "+") {
            # It's a project
            projects = projects (n_projects > 0 ? " " : "") token
            n_projects++
        }
        # Remove this token and continue
        remaining = substr(remaining, 1, RSTART - 1) substr(remaining, RSTART + RLENGTH)
    }
    
    return contexts " " projects
}

function remove_contexts_projects(line) {
    # Remove contexts and projects, preserving other @ and + usage
    gsub(/@[^[:space:]@]+/, "", line)
    gsub(/\+[^[:space:]\+]+/, "", line)
    # Clean up extra spaces
    gsub(/[[:space:]]+/, " ", line)
    gsub(/^[[:space:]]+|[[:space:]]+$/, "", line)
    return line
}

function normalize_metadata(line) {
    # Find metadata tokens (key:value where key starts with letter, and not URLs)
    result = line
    changed = 0
    
    # Pattern for metadata: letter followed by optional letters/digits, then colon, then non-space value
    # Exclude URLs by checking if colon is followed by //
    while (match(result, /[[:alpha:]][[:alnum:]]*[[:space:]]*:[[:space:]]*[^[:space:]]+/)) {
        token = substr(result, RSTART, RLENGTH)
        
        # Skip if this looks like a URL (colon followed by //)
        if (match(token, /:[[:space:]]*\/\//)) {
            # Find next occurrence
            result = substr(result, 1, RSTART + RLENGTH - 1) "SKIP_TOKEN" substr(result, RSTART + RLENGTH)
            continue
        }
        
        # Normalize spacing around colon
        if (match(token, /([[:alpha:]][[:alnum:]]*)[[:space:]]*:[[:space:]]*(.*)/)) {
            key = substr(token, 1, RSTART - 1)
            value = substr(token, RSTART + RLENGTH)
            # Extract the key and value
            match(token, /([[:alpha:]][[:alnum:]]*)[[:space:]]*:[[:space:]]*(.*)/, parts)
            if (parts[1] != "" && parts[2] != "") {
                normalized_token = parts[1] ":" parts[2]
                if (normalized_token != token) {
                    changed = 1
                }
                result = substr(result, 1, RSTART - 1) normalized_token substr(result, RSTART + RLENGTH)
            }
        }
    }
    
    # Restore skipped tokens
    gsub(/SKIP_TOKEN/, "", result)
    
    return result
}

function process_incomplete_task(line) {
    original = line
    changed = 0
    
    # Step 1: Clean up whitespace
    gsub(/^[[:space:]]+|[[:space:]]+$/, "", line)
    gsub(/[[:space:]]+/, " ", line)
    
    # Step 2: Extract and normalize priority
    priority = extract_priority(line)
    if (priority != "") {
        line = remove_priority(line, priority)
        if (!match(original, /^\([A-Z]\)[[:space:]]/)) {
            priorities_fixed++
            changed = 1
        }
    }
    
    # Step 3: Extract and normalize creation date
    creation_date = ""
    words_count = split(line, words, " ")
    for (i = 1; i <= words_count; i++) {
        normalized = normalize_date(words[i])
        if (normalized != "" && is_valid_date(normalized)) {
            creation_date = normalized
            if (normalized != words[i]) {
                dates_normalized++
                changed = 1
            }
            # Remove this date from the line
            for (j = i; j < words_count; j++) {
                words[j] = words[j + 1]
            }
            words_count--
            break
        }
    }
    
    # Rebuild line without the date
    line = ""
    for (i = 1; i <= words_count; i++) {
        line = line (i > 1 ? " " : "") words[i]
    }
    
    # Step 4: Extract contexts and projects
    contexts_projects = extract_contexts_projects(line)
    if (contexts_projects != " ") {
        # Check if repositioning is needed
        if (match(original, /^@|^\\+/)) {
            contexts_repositioned++
            changed = 1
        }
        line = remove_contexts_projects(line)
    }
    
    # Step 5: Normalize metadata
    old_line = line
    line = normalize_metadata(line)
    if (line != old_line) {
        metadata_fixed++
        changed = 1
    }
    
    # Step 6: Reassemble the line
    result = ""
    if (priority != "") {
        result = priority " "
    }
    if (creation_date != "") {
        result = result creation_date " "
    }
    result = result line
    if (contexts_projects != " ") {
        result = result " " contexts_projects
    }
    
    # Clean up final spacing
    gsub(/[[:space:]]+/, " ", result)
    gsub(/^[[:space:]]+|[[:space:]]+$/, "", result)
    
    if (changed || result != original) {
        incomplete_changed++
        if (result != original) {
            log_change(NR, "incomplete", original, result, "Normalized incomplete task")
        }
    }
    
    return result
}

function process_completed_task(line) {
    original = line
    changed = 0
    
    # Step 1: Ensure proper x format
    if (!match(line, /^x[[:space:]]/)) {
        if (match(line, /^[Xx]/)) {
            line = "x " substr(line, 2)
            changed = 1
        }
    }
    
    # Remove leading x and space for processing
    task_content = substr(line, 3)
    
    # Step 2: Extract completion date
    completion_date = ""
    words_count = split(task_content, words, " ")
    if (words_count > 0) {
        normalized = normalize_date(words[1])
        if (normalized != "" && is_valid_date(normalized)) {
            completion_date = normalized
            if (normalized != words[1]) {
                dates_normalized++
                changed = 1
            }
            # Remove completion date from words
            for (i = 1; i < words_count; i++) {
                words[i] = words[i + 1]
            }
            words_count--
        } else if (assume_today) {
            completion_date = current_date
            changed = 1
        }
    }
    
    # Step 3: Look for creation date
    creation_date = ""
    if (words_count > 0) {
        normalized = normalize_date(words[1])
        if (normalized != "" && is_valid_date(normalized)) {
            creation_date = normalized
            if (normalized != words[1]) {
                dates_normalized++
                changed = 1
            }
            # Remove creation date from words
            for (i = 1; i < words_count; i++) {
                words[i] = words[i + 1]
            }
            words_count--
        }
    }
    
    # Rebuild task content without dates
    task_content = ""
    for (i = 1; i <= words_count; i++) {
        task_content = task_content (i > 1 ? " " : "") words[i]
    }
    
    # Step 4: Remove any priority tokens (not allowed in completed tasks)
    old_task_content = task_content
    if (match(task_content, /\([A-Za-z]\)/)) {
        gsub(/\([A-Za-z]\)[[:space:]]*/, "", task_content)
        priorities_removed++
        changed = 1
    }
    
    # Step 5: Normalize metadata
    task_content = normalize_metadata(task_content)
    if (task_content != old_task_content) {
        metadata_fixed++
        changed = 1
    }
    
    # Step 6: Reassemble completed task
    result = "x"
    if (completion_date != "") {
        result = result " " completion_date
    }
    if (creation_date != "") {
        result = result " " creation_date
    }
    if (task_content != "") {
        result = result " " task_content
    }
    
    # Clean up spacing
    gsub(/[[:space:]]+/, " ", result)
    gsub(/^[[:space:]]+|[[:space:]]+$/, "", result)
    
    if (changed || result != original) {
        completed_changed++
        if (result != original) {
            log_change(NR, "completed", original, result, "Normalized completed task")
        }
    }
    
    return result
}

# Main processing loop
{
    total_lines++
    original_line = $0
    
    # Track sections for sorting
    if (is_blank_line($0) || is_comment_line($0)) {
        if (in_task_section) {
            printf "SECTION_END|%d\n", section_id
            in_task_section = 0
        }
        
        if (is_blank_line($0)) {
            blanks_preserved++
            printf "BLANK|%s\n", $0
        } else {
            comments_preserved++
            printf "COMMENT|%s\n", $0
        }
    } else {
        # This is a task line
        if (!in_task_section) {
            section_id++
            printf "SECTION_START|%d\n", section_id
            in_task_section = 1
        }
        
        tasks_processed++
        
        if (is_completed_task($0)) {
            normalized = process_completed_task($0)
        } else {
            normalized = process_incomplete_task($0)
        }
        
        # Generate sort key for this task
        sort_key = ""
        if (file_type == "todo") {
            # Sort by: priority presence, priority letter, creation date, description
            priority = extract_priority(normalized)
            priority_present = (priority != "") ? "0" : "1"
            priority_letter = (priority != "") ? substr(priority, 2, 1) : "Z"
            
            # Extract creation date for sorting
            creation_date = ""
            if (priority != "") {
                remaining = substr(normalized, length(priority) + 2)
            } else {
                remaining = normalized
            }
            split(remaining, words, " ")
            if (length(words) > 0) {
                test_date = normalize_date(words[1])
                if (test_date != "" && is_valid_date(test_date)) {
                    creation_date = test_date
                }
            }
            if (creation_date == "") creation_date = "9999-99-99"
            
            # Description for final sort
            description = tolower(normalized)
            gsub(/\([A-Z]\)[[:space:]]*/, "", description)  # Remove priority
            gsub(/[0-9]{4}-[0-9]{2}-[0-9]{2}[[:space:]]*/, "", description)  # Remove dates
            
            sort_key = priority_present "|" priority_letter "|" creation_date "|" description
        } else {
            # Sort done.txt by completion date, then description
            completion_date = "9999-99-99"
            if (match(normalized, /^x[[:space:]]+([0-9]{4}-[0-9]{2}-[0-9]{2})/)) {
                completion_date = substr(normalized, RSTART + 2, RLENGTH - 2)
            }
            description = tolower(normalized)
            sort_key = completion_date "|" description
        }
        
        printf "TASK|%d|%s|%s\n", section_id, sort_key, normalized
    }
}

END {
    if (in_task_section) {
        printf "SECTION_END|%d\n", section_id
    }
    
    # Output statistics
    log_stats("total_lines", total_lines)
    log_stats("tasks_processed", tasks_processed)
    log_stats("comments_preserved", comments_preserved)
    log_stats("blanks_preserved", blanks_preserved)
    log_stats("incomplete_changed", incomplete_changed)
    log_stats("completed_changed", completed_changed)
    log_stats("priorities_fixed", priorities_fixed)
    log_stats("dates_normalized", dates_normalized)
    log_stats("ambiguous_dates", ambiguous_dates)
    log_stats("contexts_repositioned", contexts_repositioned)
    log_stats("metadata_fixed", metadata_fixed)
    log_stats("priorities_removed", priorities_removed)
}
EOF
}

# Process a single file
process_file() {
    local file_path="$1"
    local file_type="$2"  # "todo" or "done"
    
    log_info "Processing $file_type file: $file_path"
    
    # Create file if it doesn't exist
    if [[ ! -f "$file_path" ]]; then
        log_info "Creating new file: $file_path"
        touch "$file_path"
    fi
    
    # Set up environment for AWK
    export CURRENT_DATE
    CURRENT_DATE=$(get_current_date)
    export ASSUME_TODAY
    ASSUME_TODAY=$ASSUME_TODAY_COMPLETION
    export FILE_TYPE
    FILE_TYPE=$file_type
    
    # Create temporary files
    local temp_processed="$TEMP_DIR/processed_${file_type}.txt"
    local temp_output="$TEMP_DIR/output_${file_type}.txt"
    local temp_changes="$TEMP_DIR/changes_${file_type}.txt"
    local temp_stats="$TEMP_DIR/stats_${file_type}.txt"
    
    # Process with AWK
    log_verbose "Running normalization for $file_type"
    
    # Create AWK script file
    local temp_awk="$TEMP_DIR/normalizer_${file_type}.awk"
    get_awk_normalizer > "$temp_awk"
    
    # Run AWK and capture output
    awk -f "$temp_awk" "$file_path" 2>"$TEMP_DIR/stderr_${file_type}.txt" > "$temp_processed"
    
    # Process stderr output for stats and changes
    if [[ -f "$TEMP_DIR/stderr_${file_type}.txt" ]]; then
        while IFS='|' read -r prefix data || [[ -n "$prefix" ]]; do
            case "$prefix" in
                STAT) echo "$data" >> "$temp_stats" ;;
                CHANGE) echo "$data" >> "$temp_changes" ;;
            esac
        done < "$TEMP_DIR/stderr_${file_type}.txt"
    fi
    
    # Sort within sections if enabled
    if [[ $NO_SORT != true ]]; then
        log_verbose "Sorting tasks within sections for $file_type"
        
        awk '
            /^SECTION_START\|/ {
                section_id = substr($0, index($0, "|") + 1)
                in_section = 1
                print $0
                next
            }
            /^SECTION_END\|/ {
                if (in_section) {
                    # Sort accumulated tasks
                    n = asort(sort_keys)
                    for (i = 1; i <= n; i++) {
                        print tasks[sort_keys[i]]
                    }
                    delete tasks
                    delete sort_keys
                }
                in_section = 0
                print $0
                next
            }
            /^TASK\|/ {
                if (in_section) {
                    # Extract task data: TASK|section|sort_key|content
                    n = split($0, parts, "|")
                    if (n >= 4) {
                        sort_key = parts[3]
                        content = parts[4]
                        for (i = 5; i <= n; i++) {
                            content = content "|" parts[i]
                        }
                        # Use line number to ensure stable sort
                        full_sort_key = sort_key "|" NR
                        sort_keys[length(sort_keys) + 1] = full_sort_key
                        tasks[full_sort_key] = content
                    }
                } else {
                    print $0
                }
                next
            }
            {
                print $0
            }
        ' "$temp_processed" > "$temp_output"
    else
        log_verbose "Sorting disabled, preserving original order"
        # Just extract content from TASK lines
        awk '
            /^TASK\|/ {
                # Extract task data: TASK|section|sort_key|content
                n = split($0, parts, "|")
                if (n >= 4) {
                    content = parts[4]
                    for (i = 5; i <= n; i++) {
                        content = content "|" parts[i]
                    }
                    print content
                }
                next
            }
            /^COMMENT\|/ {
                print substr($0, 9)  # Remove "COMMENT|" prefix
                next
            }
            /^BLANK\|/ {
                print substr($0, 7)  # Remove "BLANK|" prefix
                next
            }
            /^SECTION_START\||^SECTION_END\|/ {
                # Skip section markers
                next
            }
            {
                print $0
            }
        ' "$temp_processed" > "$temp_output"
    fi
    
    # Check if changes were made
    local changes_made=false
    if ! diff -q "$file_path" "$temp_output" >/dev/null 2>&1; then
        changes_made=true
        log_info "Changes detected in $file_type"
        
        # Show diff if verbose or not quiet
        if [[ $VERBOSE == true || ($QUIET != true && $CHECK_ONLY != true) ]]; then
            echo
            echo "${CYAN}=== Changes for $file_type: $file_path ===${RESET}"
            
            if command -v git >/dev/null 2>&1 && [[ $NO_COLOR != true ]]; then
                git diff --no-index --color=always "$file_path" "$temp_output" 2>/dev/null || \
                diff -u "$file_path" "$temp_output" 2>/dev/null || true
            else
                diff -u "$file_path" "$temp_output" 2>/dev/null || true
            fi
            echo
        fi
    else
        log_info "No changes needed for $file_type"
    fi
    
    # Apply changes if not in dry-run or check-only mode
    if [[ $changes_made == true && $DRY_RUN != true && $CHECK_ONLY != true ]]; then
        # Create backup first
        if ! create_backup "$file_path" "$BACKUP_DIR"; then
            log_error "Failed to create backup for $file_path"
            return 1
        fi
        
        # Atomically replace the original file
        if ! mv "$temp_output" "$file_path"; then
            log_error "Failed to update $file_path"
            return 1
        fi
        
        log_info "Successfully updated $file_type: $file_path"
    elif [[ $changes_made == true && ($DRY_RUN == true || $CHECK_ONLY == true) ]]; then
        EXIT_CODE=2
    fi
    
    # Accumulate statistics
    if [[ -f "$temp_stats" ]]; then
        while IFS='|' read -r key value; do
            case "$key" in
                total_lines) ((STATS_TOTAL_LINES += value)) ;;
                tasks_processed) ((STATS_TASKS_PROCESSED += value)) ;;
                comments_preserved) ((STATS_COMMENTS_PRESERVED += value)) ;;
                blanks_preserved) ((STATS_BLANKS_PRESERVED += value)) ;;
                incomplete_changed) ((STATS_INCOMPLETE_CHANGED += value)) ;;
                completed_changed) ((STATS_COMPLETED_CHANGED += value)) ;;
                priorities_fixed) ((STATS_PRIORITIES_FIXED += value)) ;;
                dates_normalized) ((STATS_DATES_NORMALIZED += value)) ;;
                ambiguous_dates) ((STATS_AMBIGUOUS_DATES += value)) ;;
                contexts_repositioned) ((STATS_CONTEXTS_REPOSITIONED += value)) ;;
                metadata_fixed) ((STATS_METADATA_FIXED += value)) ;;
                priorities_removed) ((STATS_PRIORITIES_REMOVED += value)) ;;
            esac
        done < "$temp_stats"
    fi
    
    return 0
}

# Print final statistics
print_statistics() {
    if [[ $QUIET != true ]]; then
        echo
        echo "${GREEN}=== Formatting Statistics ===${RESET}"
        echo "Total lines processed: $STATS_TOTAL_LINES"
        echo "Tasks processed: $STATS_TASKS_PROCESSED"
        echo "Comments preserved: $STATS_COMMENTS_PRESERVED"
        echo "Blank lines preserved: $STATS_BLANKS_PRESERVED"
        echo
        echo "Changes made:"
        echo "  Incomplete tasks changed: $STATS_INCOMPLETE_CHANGED"
        echo "  Completed tasks changed: $STATS_COMPLETED_CHANGED"
        echo "  Priorities fixed: $STATS_PRIORITIES_FIXED"
        echo "  Dates normalized: $STATS_DATES_NORMALIZED"
        echo "  Contexts/projects repositioned: $STATS_CONTEXTS_REPOSITIONED"
        echo "  Metadata spacing fixed: $STATS_METADATA_FIXED"
        echo "  Priorities removed from done: $STATS_PRIORITIES_REMOVED"
        echo
        if [[ $STATS_AMBIGUOUS_DATES -gt 0 ]]; then
            echo "${YELLOW}Warnings: $STATS_AMBIGUOUS_DATES ambiguous dates found${RESET}"
        fi
        if [[ $STATS_ERRORS -gt 0 ]]; then
            echo "${RED}Errors: $STATS_ERRORS errors encountered${RESET}"
        fi
    fi
}

# Main function
main() {
    # Parse arguments
    parse_args "$@"
    
    if [[ $SHOW_HELP == true ]]; then
        show_help
        exit 0
    fi
    
    # Initialize colors
    init_colors
    
    # Set default paths if not provided
    if [[ -z "$TODO_PATH" ]]; then
        TODO_PATH="$DEFAULT_TODO_PATH"
    fi
    if [[ -z "$DONE_PATH" ]]; then
        DONE_PATH="$DEFAULT_DONE_PATH"
    fi
    
    # Resolve paths
    TODO_PATH=$(resolve_path "$TODO_PATH")
    DONE_PATH=$(resolve_path "$DONE_PATH")
    
    if [[ -n "$BACKUP_DIR" ]]; then
        BACKUP_DIR=$(resolve_path "$BACKUP_DIR")
        if [[ ! -d "$BACKUP_DIR" ]]; then
            log_error "Backup directory does not exist: $BACKUP_DIR"
            exit 1
        fi
    fi
    
    log_verbose "Todo file: $TODO_PATH"
    log_verbose "Done file: $DONE_PATH"
    
    # Validate file access
    if ! validate_file_access "$TODO_PATH" "todo.txt"; then
        exit 1
    fi
    if ! validate_file_access "$DONE_PATH" "done.txt"; then
        exit 1
    fi
    
    # Acquire locks
    if ! acquire_lock "$TODO_PATH"; then
        exit 1
    fi
    if ! acquire_lock "$DONE_PATH"; then
        exit 1
    fi
    
    # Initialize temporary directory
    init_temp_dir
    
    # Process files
    local success=true
    
    if ! process_file "$TODO_PATH" "todo"; then
        success=false
    fi
    
    if ! process_file "$DONE_PATH" "done"; then
        success=false
    fi
    
    # Print statistics
    print_statistics
    
    if [[ $success != true ]]; then
        EXIT_CODE=1
    fi
    
    # Final status message
    if [[ $EXIT_CODE -eq 0 ]]; then
        if [[ $DRY_RUN == true ]]; then
            log_info "Dry run completed successfully"
        elif [[ $CHECK_ONLY == true ]]; then
            log_info "Check completed - no issues found"
        else
            log_info "Formatting completed successfully"
        fi
    elif [[ $EXIT_CODE -eq 2 ]]; then
        log_info "Issues found but no changes applied (dry-run or check-only mode)"
    else
        log_error "Formatting failed with errors"
    fi
    
    exit $EXIT_CODE
}

# Run main function with all arguments
main "$@"