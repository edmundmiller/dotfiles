#!/bin/bash
#
# Simple Todo.txt Formatter
# 
# A straightforward formatter for todo.txt files that handles the most common issues:
# - Priority placement and normalization
# - Date normalization  
# - Context/project repositioning
# - Metadata spacing
# - Basic completed task validation
#

set -euo pipefail

# Configuration
TODO_PATH="${1:-$HOME/Documents/todo/todo.txt}"
DONE_PATH="${2:-$HOME/Documents/todo/done.txt}"
DRY_RUN="${3:-false}"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'  
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
RESET='\033[0m'

echo_info() { echo -e "${GREEN}INFO:${RESET} $*" >&2; }
echo_warning() { echo -e "${YELLOW}WARNING:${RESET} $*" >&2; }
echo_error() { echo -e "${RED}ERROR:${RESET} $*" >&2; }

# Function to normalize a single todo.txt line
normalize_line() {
    local line="$1"
    local file_type="$2"  # "todo" or "done"
    
    # Skip blank lines and comments
    if [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]]; then
        echo "$line"
        return
    fi
    
    # Handle completed tasks
    if [[ "$line" =~ ^[xX] ]]; then
        # Fix X to lowercase x
        line=$(echo "$line" | sed 's/^X /x /')
        
        # Remove priority tokens from completed tasks (they shouldn't have them)
        line=$(echo "$line" | sed 's/([A-Za-z])[[:space:]]*//g')
        
        # Fix metadata spacing: remove spaces around colons
        line=$(echo "$line" | sed 's/[[:space:]]*:[[:space:]]*/:/g')
        
        echo "$line"
        return
    fi
    
    # Process incomplete tasks
    local priority=""
    local creation_date=""
    local description=""
    local contexts_projects=""
    local metadata=""
    
    # Extract priority (first occurrence)
    if [[ "$line" =~ \(([A-Za-z])\) ]]; then
        priority="($(echo "${BASH_REMATCH[1]}" | tr '[:lower:]' '[:upper:]'))"
        line=$(echo "$line" | sed 's/([A-Za-z])[[:space:]]*//' | sed 's/^[[:space:]]*//')
    fi
    
    # Extract creation date (first valid date)
    local words=($line)
    local remaining_words=()
    local found_date=false
    
    for word in "${words[@]}"; do
        if [[ ! $found_date && "$word" =~ ^[0-9]{4}[-/.]?[0-9]{1,2}[-/.]?[0-9]{1,2}$ ]]; then
            # Normalize date format
            if [[ "$word" =~ ^[0-9]{4}[0-9]{2}[0-9]{2}$ ]]; then
                # YYYYMMDD format
                creation_date="${word:0:4}-${word:4:2}-${word:6:2}"
            elif [[ "$word" =~ ^[0-9]{4}[-/.][0-9]{1,2}[-/.][0-9]{1,2}$ ]]; then
                # YYYY-MM-DD, YYYY/MM/DD, or YYYY.MM.DD format
                creation_date=$(echo "$word" | sed 's|[/.]|-|g' | sed 's/-\([0-9]\)$/-0\1/' | sed 's/-\([0-9]\)-/-0\1-/')
            fi
            found_date=true
        else
            remaining_words+=("$word")
        fi
    done
    
    # Process remaining words
    local desc_words=()
    local context_project_words=()
    local metadata_words=()
    
    for word in "${remaining_words[@]}"; do
        if [[ "$word" =~ ^@[^@[:space:]]+ && ! "$word" =~ ^@.*@.*$ ]]; then
            # Context (@ but not email)
            context_project_words+=("$word")
        elif [[ "$word" =~ ^\+[^[:space:]]+ ]]; then
            # Project (keep the + sign) 
            context_project_words+=("$word")
        elif [[ "$word" =~ ^[a-zA-Z][a-zA-Z0-9]*:[^/] ]]; then
            # Metadata (key:value, not URL)
            metadata_words+=("$(echo "$word" | sed 's/[[:space:]]*:[[:space:]]*/:/g')")
        else
            desc_words+=("$word")
        fi
    done
    
    # Reassemble line
    local result=""
    [[ -n "$priority" ]] && result="$priority"
    [[ -n "$creation_date" ]] && result="${result:+$result }$creation_date"
    [[ ${#desc_words[@]} -gt 0 ]] && result="${result:+$result }${desc_words[*]}"
    [[ ${#context_project_words[@]} -gt 0 ]] && result="${result:+$result }${context_project_words[*]}"
    [[ ${#metadata_words[@]} -gt 0 ]] && result="${result:+$result }${metadata_words[*]}"
    
    # Clean up extra spaces (should be minimal now)
    result=$(echo "$result" | sed 's/[[:space:]]+/ /g' | sed 's/^[[:space:]]*\|[[:space:]]*$//')
    
    echo "$result"
}

# Process a file
process_file() {
    local file_path="$1"
    local file_type="$2"
    local temp_output="/tmp/formatter_${file_type}_output_$$"
    
    echo_info "Processing $file_type: $file_path"
    
    if [[ ! -f "$file_path" ]]; then
        echo_warning "$file_type file not found: $file_path"
        return 0
    fi
    
    # Process each line
    local line_num=0
    local changes_made=false
    
    while IFS= read -r line || [[ -n "$line" ]]; do
        ((line_num++))
        normalized_line=$(normalize_line "$line" "$file_type")
        
        if [[ "$normalized_line" != "$line" ]]; then
            changes_made=true
            echo_info "Line $line_num changed:"
            echo_info "  Before: $line"
            echo_info "  After:  $normalized_line"
        fi
        
        echo "$normalized_line" >> "$temp_output"
    done < "$file_path"
    
    if [[ $changes_made == true ]]; then
        echo_info "Changes detected in $file_type"
        
        # Show diff
        echo -e "\n${CYAN}=== Diff for $file_type ===${RESET}"
        if command -v git >/dev/null 2>&1; then
            git diff --no-index --color=always "$file_path" "$temp_output" 2>/dev/null || \
            diff -u "$file_path" "$temp_output" 2>/dev/null || true
        else
            diff -u "$file_path" "$temp_output" 2>/dev/null || true
        fi
        echo
        
        if [[ "$DRY_RUN" != "true" ]]; then
            # Create backup
            local backup_path="${file_path}.$(date '+%Y%m%d-%H%M%S').bak"
            cp "$file_path" "$backup_path"
            echo_info "Backup created: $backup_path"
            
            # Apply changes
            mv "$temp_output" "$file_path"
            echo_info "Successfully updated $file_type"
        fi
    else
        echo_info "No changes needed for $file_type"
        rm -f "$temp_output"
    fi
}

# Show usage
show_usage() {
    cat << 'EOF'
Todo.txt Simple Formatter

USAGE:
    formatter-simple [TODO_PATH] [DONE_PATH] [DRY_RUN]

ARGUMENTS:
    TODO_PATH    Path to todo.txt (default: ~/Documents/todo/todo.txt)
    DONE_PATH    Path to done.txt (default: ~/Documents/todo/done.txt)  
    DRY_RUN      Set to 'true' for dry-run mode (default: false)

EXAMPLES:
    formatter-simple
    formatter-simple ~/my-todo.txt ~/my-done.txt
    formatter-simple ~/my-todo.txt ~/my-done.txt true

FEATURES:
    ✓ Priority normalization: (A), (B), (C) at start of line
    ✓ Date formatting: YYYY-MM-DD format
    ✓ Context (@) and project (+) repositioning  
    ✓ Metadata spacing: key:value format
    ✓ Completed task validation
    ✓ Backup creation
    ✓ Colored diffs

EOF
}

# Main execution
main() {
    if [[ $# -gt 0 && ("$1" == "-h" || "$1" == "--help") ]]; then
        show_usage
        exit 0
    fi
    
    echo_info "Todo.txt Simple Formatter"
    echo_info "Todo file: $TODO_PATH"
    echo_info "Done file: $DONE_PATH"
    
    if [[ "$DRY_RUN" == "true" ]]; then
        echo_info "DRY RUN MODE - No changes will be applied"
    fi
    
    # Process files
    process_file "$TODO_PATH" "todo"
    process_file "$DONE_PATH" "done"
    
    echo_info "Formatting complete"
}

main "$@"