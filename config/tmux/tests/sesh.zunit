#!/usr/bin/env zunit

# Tests for sesh session picker integration
# Covers: binary existence, zoxide list quality, tmux popup interaction
#
# NOTE: Tests requiring live services (tmux server, sesh sessions, zoxide db)
# are skipped when those services are unavailable (e.g. Nix sandbox / CI).

@setup {
  export ORIG_PWD=$PWD
  export SESH_SCRIPT="$ORIG_PWD/config/tmux/sesh-picker.sh"
  export ZOXIDE_SCRIPT="$ORIG_PWD/config/tmux/zoxide-list.sh"
}

# ── Binary checks ──────────────────────────────────────────────────────────────

@test 'sesh binary is available' {
  command -v sesh > /dev/null 2>&1 || skip "sesh not in PATH"
  run sesh --version
  assert $state equals 0
}

@test 'fzf binary is available' {
  command -v fzf > /dev/null 2>&1 || skip "fzf not in PATH"
  run fzf --version
  assert $state equals 0
}

@test 'zoxide binary is available' {
  command -v zoxide > /dev/null 2>&1 || skip "zoxide not in PATH"
  run zoxide --version
  assert $state equals 0
}

# ── Script checks ──────────────────────────────────────────────────────────────

@test 'sesh-picker.sh is executable' {
  [[ -x "$SESH_SCRIPT" ]]
  assert $state equals 0
}

@test 'zoxide-list.sh is executable' {
  [[ -x "$ZOXIDE_SCRIPT" ]]
  assert $state equals 0
}

# ── sesh list output ───────────────────────────────────────────────────────────

@test 'sesh list returns output' {
  # Requires a running tmux server
  [[ -n "$TMUX" ]] || skip "not inside tmux"
  command -v sesh > /dev/null 2>&1 || skip "sesh not in PATH"
  run sesh list
  assert $state equals 0
  assert "$output" is_not_empty
}

@test 'sesh list -t returns only tmux sessions' {
  # Requires a running tmux server
  [[ -n "$TMUX" ]] || skip "not inside tmux"
  command -v sesh > /dev/null 2>&1 || skip "sesh not in PATH"
  run sesh list -t
  assert $state equals 0
}

# ── zoxide-list.sh quality ─────────────────────────────────────────────────────

@test 'zoxide-list.sh returns output' {
  # Requires a populated zoxide database
  command -v zoxide > /dev/null 2>&1 || skip "zoxide not in PATH"
  local count
  count=$(zoxide query --list 2>/dev/null | wc -l | tr -d ' ')
  [[ "$count" -gt 0 ]] || skip "zoxide database is empty"
  run "$ZOXIDE_SCRIPT"
  assert $state equals 0
  assert "$output" is_not_empty
}

@test 'zoxide-list.sh returns at most 30 lines' {
  command -v zoxide > /dev/null 2>&1 || skip "zoxide not in PATH"
  local db_count
  db_count=$(zoxide query --list 2>/dev/null | wc -l | tr -d ' ')
  [[ "$db_count" -gt 0 ]] || skip "zoxide database is empty"
  local count=$("$ZOXIDE_SCRIPT" | wc -l | tr -d ' ')
  [[ "$count" -le 30 ]]
  assert $state equals 0
}

@test 'zoxide-list.sh excludes temp and noise dirs' {
  command -v zoxide > /dev/null 2>&1 || skip "zoxide not in PATH"
  local db_count
  db_count=$(zoxide query --list 2>/dev/null | wc -l | tr -d ' ')
  [[ "$db_count" -gt 0 ]] || skip "zoxide database is empty"
  local result=$("$ZOXIDE_SCRIPT")
  # Should not include common noise entries
  local noise=$(echo "$result" | grep -E '^(/tmp|/private/tmp|/private/var/folders|.*\.Trash|.*\.sdkman/tmp)' || true)
  assert "$noise" is_empty
}

@test 'zoxide-list.sh entries are real directories' {
  command -v zoxide > /dev/null 2>&1 || skip "zoxide not in PATH"
  local db_count
  db_count=$(zoxide query --list 2>/dev/null | wc -l | tr -d ' ')
  [[ "$db_count" -gt 0 ]] || skip "zoxide database is empty"
  while IFS= read -r dir; do
    [[ -d "$dir" ]] || { echo "Not a directory: $dir"; return 1; }
  done < <("$ZOXIDE_SCRIPT")
  assert $state equals 0
}

# ── Regression: fzf reload pipe parsing ───────────────────────────────────────

@test 'zoxide-list.sh uses a script not inline pipe (avoids fzf reload bug)' {
  # Regression: pipe in reload() was parsed as fzf action separator, showing "/"
  # Fix: extract to standalone script, reference by path in reload()
  local result=$(grep 'reload.*|.*head' "$SESH_SCRIPT" || true)
  assert "$result" is_empty
}

# ── Regression: minimal PATH in fzf popup ─────────────────────────────────────

@test 'sesh is NOT in minimal display-popup PATH' {
  local minimal_path="/usr/bin:/bin:/usr/sbin:/sbin"
  local result=$(env -i PATH="$minimal_path" which sesh 2>&1 || true)
  assert "$result" is_empty
}

@test 'fzf is NOT in minimal display-popup PATH' {
  local minimal_path="/usr/bin:/bin:/usr/sbin:/sbin"
  local result=$(env -i PATH="$minimal_path" which fzf 2>&1 || true)
  assert "$result" is_empty
}

# ── tmux popup interaction ─────────────────────────────────────────────────────

@test 'sesh picker popup appears and closes cleanly on escape' {
  # Skip if not inside tmux
  [[ -n "$TMUX" ]] || skip "not inside tmux"

  local test_window
  test_window=$(tmux new-window -d -P -F '#{window_id}')

  # Run the picker in the test window (it will show the fzf-tmux popup)
  tmux send-keys -t "$test_window" "$SESH_SCRIPT" Enter
  sleep 1

  # Capture popup content — should show the sesh border label
  local pane_output
  pane_output=$(tmux capture-pane -t "$test_window" -p 2>/dev/null || true)

  # Send escape to dismiss
  tmux send-keys -t "$test_window" Escape ''
  sleep 0.3
  tmux kill-window -t "$test_window" 2>/dev/null || true

  # Popup should have shown the sesh border or fzf prompt
  echo "$pane_output" | grep -qE 'sesh|> $'
  assert $state equals 0
}

@test 'sesh picker exits 0 when no session selected (escape logic)' {
  # Regression: empty sesh connect returned 127; [ -n ] + exit 0 guards against it
  # Test the guard logic directly without needing a live fzf popup
  run bash -c 'SESSION=""; [ -n "$SESSION" ] && sesh connect "$SESSION"; exit 0'
  assert $state equals 0
}
